# ================== IMPORTY ==================
import discord
from discord.ext import commands
from discord import app_commands
from discord.ui import View, Button, Select
import yt_dlp
import asyncio
import datetime, os

# ================== KONFIG ==================
GUILD_ID = 1378797704133742774
VERIFIED_ROLE_ID = 1437464785334833253
TICKET_CATEGORY_ID = 1442217936768209188
STAFF_ROLE_ID = 1379102924617027655

LOG_PATH = "/home/iseeyou/Pulpit/Logi/logi.md"

OSTATNIA_LITERA_ID = 1234567890
OSOBA_PONIZEJ_ID = 1234567890
LICZENIA_ID = 1234567890

# ================== INTENTY ==================
intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

# ================== LOGI ==================
def log_to_file(text: str):
    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)
    with open(LOG_PATH, "a", encoding="utf-8") as f:
        f.write(f"- `{ts}` {text}\n")

# ================== STAN ==================
last_word = None
last_number = 0
last_user_game = {"litera": None, "liczenia": None}

# MAX system
DYNAMIC_CHANNELS = {}
TEMP_VC = {}
VC_OWNER = {}
USER_MAX_COUNT = {}

MAX_PER_USER = 3

# ================== STATYSTYKI ==================
STATS = {
    "max_created": 0,
    "vc_created": 0,
    "vc_deleted": 0
}

# ================== READY ==================
@bot.event
async def on_ready():
    TEMP_VC.clear()
    VC_OWNER.clear()
    USER_MAX_COUNT.clear()

    await bot.tree.sync(guild=discord.Object(id=GUILD_ID))
    print(f"‚úÖ Zalogowano jako {bot.user}")

# ================== VIEWS ==================
class VerifyView(View):
    @discord.ui.button(label="‚úÖ Zweryfikuj siƒô", style=discord.ButtonStyle.green)
    async def verify(self, i: discord.Interaction, b: Button):
        role = i.guild.get_role(VERIFIED_ROLE_ID)
        if role:
            await i.user.add_roles(role)
            await i.response.send_message("‚úÖ Zweryfikowano", ephemeral=True)

class TicketActionView(View):
    def __init__(self, channel):
        super().__init__()
        self.channel = channel

    @discord.ui.button(label="üóëÔ∏è Zamknij", style=discord.ButtonStyle.red)
    async def close(self, i, b):
        await self.channel.delete()

class TicketSelect(Select):
    def __init__(self):
        super().__init__(
            placeholder="Wybierz typ ticketu",
            options=[
                discord.SelectOption(label="Support"),
                discord.SelectOption(label="Skarga"),
                discord.SelectOption(label="Propozycja")
            ]
        )

    async def callback(self, i: discord.Interaction):
        guild = i.guild
        category = guild.get_channel(TICKET_CATEGORY_ID)
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(view_channel=False),
            i.user: discord.PermissionOverwrite(view_channel=True),
            guild.get_role(STAFF_ROLE_ID): discord.PermissionOverwrite(view_channel=True)
        }
        ch = await guild.create_text_channel(
            f"ticket-{i.user.name}".lower(),
            category=category,
            overwrites=overwrites
        )
        await ch.send(view=TicketActionView(ch))
        await i.response.send_message(f"üé´ Utworzono {ch.mention}", ephemeral=True)

class TicketView(View):
    def __init__(self):
        super().__init__()
        self.add_item(TicketSelect())

class VoiceControlView(View):
    @discord.ui.button(label="üîá Mute", style=discord.ButtonStyle.gray)
    async def mute(self, i, b):
        if i.guild.voice_client:
            i.guild.voice_client.pause()
            await i.response.send_message("üîá Wyciszono", ephemeral=True)

    @discord.ui.button(label="üîä Unmute", style=discord.ButtonStyle.green)
    async def unmute(self, i, b):
        if i.guild.voice_client:
            i.guild.voice_client.resume()
            await i.response.send_message("üîä Wznowiono", ephemeral=True)

    @discord.ui.button(label="‚èπÔ∏è Wyjd≈∫", style=discord.ButtonStyle.red)
    async def leave(self, i, b):
        if i.guild.voice_client:
            await i.guild.voice_client.disconnect()
            await i.response.send_message("üëã Bot wyszed≈Ç z VC", ephemeral=True)

class MenuView(View):
    @discord.ui.button(label="üé´ Tickety", style=discord.ButtonStyle.green)
    async def t(self, i, b):
        await i.response.send_message("U≈ºyj /ticket", ephemeral=True)

# ================== SLASH ==================
@bot.tree.command(name="ping", description="Sprawdza czy bot ≈ºyje", guild=discord.Object(id=GUILD_ID))
async def ping(i: discord.Interaction):
    await i.response.send_message(f"üèì {round(bot.latency*1000)} ms", ephemeral=True)

@bot.tree.command(name="menu", description="Pokazuje wszystkie komendy", guild=discord.Object(id=GUILD_ID))
async def menu(i: discord.Interaction):
    txt = (
        "**üìú Komendy:**\n"
        "/ping ‚Äì sprawdza czy bot ≈ºyje\n"
        "/weryfikacja ‚Äì panel weryfikacji\n"
        "/ticket ‚Äì tworzy ticket\n"
        "/max ‚Äì ustawia MAX VC\n"
        "/maxdel ‚Äì usuwa MAX po numerze\n"
        "/play ‚Äì odtwarza audio z YouTube\n"
        "/stats ‚Äì statystyki bota"
    )
    await i.response.send_message(txt, view=VoiceControlView(), ephemeral=True)

@bot.tree.command(name="ticket", description="Tworzy ticket", guild=discord.Object(id=GUILD_ID))
async def ticket(i: discord.Interaction):
    await i.response.send_message("üìÇ Wybierz:", view=TicketView(), ephemeral=True)

@bot.tree.command(name="weryfikacja", description="Wysy≈Ça panel weryfikacji", guild=discord.Object(id=GUILD_ID))
async def weryfikacja(i: discord.Interaction):
    await i.response.send_message("Kliknij aby siƒô zweryfikowaƒá:", view=VerifyView())

# ================== PLAY ==================
@bot.tree.command(
    name="play",
    description="Odtwarza audio z YouTube",
    guild=discord.Object(id=GUILD_ID)
)
async def play(i: discord.Interaction, youtube_url: str):
    if not i.user.voice:
        await i.response.send_message("‚ùå Wejd≈∫ na VC", ephemeral=True)
        return

    channel = i.user.voice.channel
    vc = i.guild.voice_client or await channel.connect()

    with yt_dlp.YoutubeDL({"format": "bestaudio", "quiet": True}) as ydl:
        info = ydl.extract_info(youtube_url, download=False)

    vc.play(discord.FFmpegPCMAudio(info["url"]))
    await i.response.send_message("‚ñ∂Ô∏è Odtwarzanie rozpoczƒôte", ephemeral=True)

# ================== MAX ==================
@bot.tree.command(name="max", description="Ustawia MAX VC", guild=discord.Object(id=GUILD_ID))
async def max_create(i: discord.Interaction, channel: discord.VoiceChannel, limit: int):
    DYNAMIC_CHANNELS[channel.id] = limit
    STATS["max_created"] += 1
    await i.response.send_message("‚úÖ MAX ustawiony", ephemeral=True)

@bot.tree.command(name="maxdel", description="Usuwa MAX po numerze", guild=discord.Object(id=GUILD_ID))
async def maxdel(i: discord.Interaction, numer: int):
    if numer < 1 or numer > len(DYNAMIC_CHANNELS):
        await i.response.send_message("‚ùå Z≈Çy numer", ephemeral=True)
        return

    max_id = list(DYNAMIC_CHANNELS.keys())[numer - 1]
    DYNAMIC_CHANNELS.pop(max_id)

    to_delete = [vc for vc, parent in TEMP_VC.items() if parent == max_id]
    for vc_id in to_delete:
        ch = i.guild.get_channel(vc_id)
        if ch:
            await ch.delete()
        TEMP_VC.pop(vc_id, None)
        VC_OWNER.pop(vc_id, None)

    await i.response.send_message(f"üóëÔ∏è Usuniƒôto MAX #{numer}", ephemeral=True)

@bot.tree.command(name="stats", description="Statystyki bota", guild=discord.Object(id=GUILD_ID))
async def stats(i: discord.Interaction):
    msg = (
        f"üìä MAX: {STATS['max_created']}\n"
        f"VC +: {STATS['vc_created']}\n"
        f"VC -: {STATS['vc_deleted']}"
    )
    await i.response.send_message(msg, ephemeral=True)

# ================== VOICE ==================
@bot.event
async def on_voice_state_update(member, before, after):
    if after.channel and after.channel.id in DYNAMIC_CHANNELS:
        uid = member.id
        USER_MAX_COUNT.setdefault(uid, 0)

        if USER_MAX_COUNT[uid] >= MAX_PER_USER:
            await member.move_to(None)
            return

        limit = DYNAMIC_CHANNELS[after.channel.id]
        parent = after.channel.category

        vc = await member.guild.create_voice_channel(
            f"{member.display_name} | {after.channel.name}",
            category=parent,
            user_limit=limit
        )

        TEMP_VC[vc.id] = after.channel.id
        VC_OWNER[vc.id] = uid
        USER_MAX_COUNT[uid] += 1
        STATS["vc_created"] += 1

        await member.move_to(vc)

    if before.channel and before.channel.id in TEMP_VC:
        if len(before.channel.members) == 0:
            owner = VC_OWNER.get(before.channel.id)
            if owner:
                USER_MAX_COUNT[owner] -= 1
            await before.channel.delete()
            TEMP_VC.pop(before.channel.id)
            VC_OWNER.pop(before.channel.id)
            STATS["vc_deleted"] += 1

    for vc in bot.voice_clients:
        if vc.channel and len(vc.channel.members) == 1:
            await vc.disconnect()

# ================== STATUS (WY≈ÅƒÑCZONE) ==================
# @bot.event
# async def on_presence_update(before, after):
#     pass

# ================== START ==================
def start_bot(token):
    bot.run(token)
