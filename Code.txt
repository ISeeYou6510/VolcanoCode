# ================== IMPORTY ==================
import discord
from discord.ext import commands
from discord import app_commands
from discord.ui import View, Button, Select
import yt_dlp
import asyncio
import datetime, os

# ================== KONFIG ==================
GUILD_ID = 1378797704133742774
VERIFIED_ROLE_ID = 1437464785334833253
TICKET_CATEGORY_ID = 1442217936768209188
STAFF_ROLE_ID = 1379102924617027655

LOG_PATH = "/home/iseeyou/Pulpit/Logi/logi.md"

OSTATNIA_LITERA_ID = 1234567890
OSOBA_PONIZEJ_ID = 1234567890
LICZENIA_ID = 1234567890

# ================== INTENTY ==================
intents = discord.Intents.all()
bot = commands.Bot(command_prefix="!", intents=intents)

# ================== LOGI ==================
def log_to_file(text: str):
    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)
    with open(LOG_PATH, "a", encoding="utf-8") as f:
        f.write(f"- `{ts}` {text}\n")

# ================== STAN ==================
last_word = None
last_number = 0
last_user_game = {"litera": None, "liczenia": None}

# MAX system
DYNAMIC_CHANNELS = {}      # max_channel_id -> limit
TEMP_VC = {}               # temp_vc_id -> max_channel_id
VC_OWNER = {}              # temp_vc_id -> user_id
USER_MAX_COUNT = {}        # user_id -> ilo≈õƒá aktywnych VC

MAX_PER_USER = 3

# ================== STATYSTYKI ==================
STATS = {
    "max_created": 0,
    "vc_created": 0,
    "vc_deleted": 0
}

# ================== READY ==================
@bot.event
async def on_ready():
    # AUTO CLEANUP
    TEMP_VC.clear()
    VC_OWNER.clear()
    USER_MAX_COUNT.clear()

    await bot.tree.sync(guild=discord.Object(id=GUILD_ID))
    print(f"‚úÖ Zalogowano jako {bot.user}")
    print("üßπ Cleanup wykonany")
    print("‚úÖ Slash commandy zsynchronizowane")

# ================== VIEWS ==================
class VerifyView(View):
    @discord.ui.button(label="‚úÖ Zweryfikuj siƒô", style=discord.ButtonStyle.green)
    async def verify(self, interaction: discord.Interaction, button: Button):
        role = interaction.guild.get_role(VERIFIED_ROLE_ID)
        if role:
            await interaction.user.add_roles(role)
            await interaction.response.send_message("‚úÖ Zweryfikowano!", ephemeral=True)

class TicketActionView(View):
    def __init__(self, channel):
        super().__init__()
        self.channel = channel

    @discord.ui.button(label="üóëÔ∏è Zamknij", style=discord.ButtonStyle.red)
    async def close(self, interaction: discord.Interaction, button: Button):
        await self.channel.delete()

class TicketSelect(Select):
    def __init__(self):
        super().__init__(
            placeholder="Wybierz typ ticketu",
            options=[
                discord.SelectOption(label="Support"),
                discord.SelectOption(label="Skarga"),
                discord.SelectOption(label="Propozycja")
            ]
        )

    async def callback(self, interaction: discord.Interaction):
        guild = interaction.guild
        category = guild.get_channel(TICKET_CATEGORY_ID)
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(view_channel=False),
            interaction.user: discord.PermissionOverwrite(view_channel=True),
            guild.get_role(STAFF_ROLE_ID): discord.PermissionOverwrite(view_channel=True)
        }
        ch = await guild.create_text_channel(
            f"ticket-{interaction.user.name}".lower(),
            category=category,
            overwrites=overwrites
        )
        await ch.send(view=TicketActionView(ch))
        await interaction.response.send_message(f"üé´ Utworzono {ch.mention}", ephemeral=True)

class TicketView(View):
    def __init__(self):
        super().__init__()
        self.add_item(TicketSelect())

class MenuView(View):
    @discord.ui.button(label="üé´ Tickety", style=discord.ButtonStyle.green)
    async def t(self, i, b):
        await i.response.send_message("U≈ºyj /ticket", ephemeral=True)

# ================== SLASH ==================
@bot.tree.command(name="ping", guild=discord.Object(id=GUILD_ID))
async def ping(i: discord.Interaction):
    await i.response.send_message(f"üèì {round(bot.latency*1000)} ms", ephemeral=True)

@bot.tree.command(name="menu", guild=discord.Object(id=GUILD_ID))
async def menu(i: discord.Interaction):
    await i.response.send_message("üìå Menu:", view=MenuView(), ephemeral=True)

@bot.tree.command(name="ticket", guild=discord.Object(id=GUILD_ID))
async def ticket(i: discord.Interaction):
    await i.response.send_message("üìÇ Wybierz:", view=TicketView(), ephemeral=True)

# ================== MAX ==================
@bot.tree.command(name="max", guild=discord.Object(id=GUILD_ID))
async def max_create(i: discord.Interaction, channel: discord.VoiceChannel, limit: int):
    DYNAMIC_CHANNELS[channel.id] = limit
    STATS["max_created"] += 1
    await i.response.send_message("‚úÖ MAX ustawiony", ephemeral=True)

@bot.tree.command(name="maxdel", guild=discord.Object(id=GUILD_ID))
async def maxdel(i: discord.Interaction, numer: int):
    if numer < 1 or numer > len(DYNAMIC_CHANNELS):
        await i.response.send_message("‚ùå Z≈Çy numer", ephemeral=True)
        return

    max_id = list(DYNAMIC_CHANNELS.keys())[numer - 1]
    DYNAMIC_CHANNELS.pop(max_id)

    to_delete = [vc for vc, parent in TEMP_VC.items() if parent == max_id]
    for vc_id in to_delete:
        ch = i.guild.get_channel(vc_id)
        if ch:
            await ch.delete()
        TEMP_VC.pop(vc_id, None)
        VC_OWNER.pop(vc_id, None)

    await i.response.send_message(f"üóëÔ∏è Usuniƒôto MAX #{numer}", ephemeral=True)

@bot.tree.command(name="stats", guild=discord.Object(id=GUILD_ID))
async def stats(i: discord.Interaction):
    msg = (
        f"üìä **Statystyki**\n"
        f"MAX utworzone: {STATS['max_created']}\n"
        f"VC stworzone: {STATS['vc_created']}\n"
        f"VC usuniƒôte: {STATS['vc_deleted']}"
    )
    await i.response.send_message(msg, ephemeral=True)

# ================== VOICE ==================
@bot.event
async def on_voice_state_update(member, before, after):
    # WEJ≈öCIE NA MAX
    if after.channel and after.channel.id in DYNAMIC_CHANNELS:
        uid = member.id
        USER_MAX_COUNT.setdefault(uid, 0)

        if USER_MAX_COUNT[uid] >= MAX_PER_USER:
            await member.move_to(None)
            return

        limit = DYNAMIC_CHANNELS[after.channel.id]
        parent = after.channel.category

        vc = await member.guild.create_voice_channel(
            f"{member.display_name} | {after.channel.name}",
            category=parent,
            user_limit=limit
        )

        TEMP_VC[vc.id] = after.channel.id
        VC_OWNER[vc.id] = uid
        USER_MAX_COUNT[uid] += 1
        STATS["vc_created"] += 1

        await member.move_to(vc)

    # USUWANIE TEMP
    if before.channel and before.channel.id in TEMP_VC:
        if len(before.channel.members) == 0:
            owner = VC_OWNER.get(before.channel.id)
            if owner:
                USER_MAX_COUNT[owner] -= 1
            await before.channel.delete()
            TEMP_VC.pop(before.channel.id)
            VC_OWNER.pop(before.channel.id)
            STATS["vc_deleted"] += 1

    # BOT WYCHODZI JAK SAM
    for vc in bot.voice_clients:
        if vc.channel and len(vc.channel.members) == 1:
            await vc.disconnect()

# ================== STATUS (WY≈ÅƒÑCZONE) ==================
# @bot.event
# async def on_presence_update(before, after):
#     if before.status != after.status:
#         log_to_file(f"{after} zmieni≈Ç status")

# ================== START ==================
def start_bot(token):
    bot.run(token)
