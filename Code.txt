# ================== IMPORTY ==================
import discord
from discord.ext import commands
from discord import app_commands
from discord.ui import View, Button, Select
import yt_dlp
import asyncio
import datetime, os

# ================== KONFIG ==================
GUILD_ID = 1378797704133742774
VERIFIED_ROLE_ID = 1437464785334833253
TICKET_CATEGORY_ID = 1442217936768209188
STAFF_ROLE_ID = 1379102924617027655

LOG_PATH = "/home/iseeyou/Pulpit/Logi/logi.md"

OSTATNIA_LITERA_ID = 1234567890
OSOBA_PONIZEJ_ID = 1234567890
LICZENIA_ID = 1234567890

# ================== INTENTY ==================
intents = discord.Intents.default()
intents.members = True
intents.message_content = True
intents.voice_states = True
intents.presences = True

bot = commands.Bot(command_prefix="!", intents=intents)

# ================== LOGI ==================
def log_to_file(text: str):
    ts = datetime.datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    os.makedirs(os.path.dirname(LOG_PATH), exist_ok=True)
    with open(LOG_PATH, "a", encoding="utf-8") as f:
        f.write(f"- `{ts}` {text}\n")

# ================== GRY ‚Äì STAN ==================
last_word = None
last_number = 0
last_user_game = {"litera": None, "liczenia": None}

# ================== WERYFIKACJA / MENU / MAX / TICKET ==================
class VerifyView(View):
    @discord.ui.button(label="‚úÖ Zweryfikuj siƒô", style=discord.ButtonStyle.green)
    async def verify(self, interaction: discord.Interaction, button: Button):
        role = interaction.guild.get_role(VERIFIED_ROLE_ID)
        if role:
            await interaction.user.add_roles(role)
            await interaction.response.send_message("‚úÖ Zweryfikowano!", ephemeral=True)
        else:
            await interaction.response.send_message("‚ùå Brak roli", ephemeral=True)

class TicketActionView(View):
    def __init__(self, channel):
        super().__init__()
        self.channel = channel

    @discord.ui.button(label="üóëÔ∏è Zamknij", style=discord.ButtonStyle.red)
    async def close(self, interaction: discord.Interaction, button: Button):
        await interaction.response.send_message("Ticket zamkniƒôty", ephemeral=True)
        await self.channel.delete()

class TicketSelect(Select):
    def __init__(self):
        options = [
            discord.SelectOption(label="Support"),
            discord.SelectOption(label="Skarga"),
            discord.SelectOption(label="Propozycja")
        ]
        super().__init__(placeholder="Wybierz typ ticketu", options=options)

    async def callback(self, interaction: discord.Interaction):
        guild = interaction.guild
        category = guild.get_channel(TICKET_CATEGORY_ID)
        overwrites = {
            guild.default_role: discord.PermissionOverwrite(view_channel=False),
            interaction.user: discord.PermissionOverwrite(view_channel=True),
            guild.get_role(STAFF_ROLE_ID): discord.PermissionOverwrite(view_channel=True)
        }
        channel = await guild.create_text_channel(
            f"ticket-{interaction.user.name}".lower(),
            category=category,
            overwrites=overwrites
        )
        await channel.send(
            f"üé´ {interaction.user.mention} utworzy≈Ç ticket **{self.values[0]}**",
            view=TicketActionView(channel)
        )
        await interaction.response.send_message(f"‚úÖ Utworzono {channel.mention}", ephemeral=True)

class TicketView(View):
    def __init__(self):
        super().__init__()
        self.add_item(TicketSelect())

class MenuView(View):
    @discord.ui.button(label="üé´ Tickety", style=discord.ButtonStyle.green)
    async def t(self, i: discord.Interaction, b: Button):
        await i.response.send_message("Tw√≥rz tickety komendƒÖ /ticket", ephemeral=True)
    @discord.ui.button(label="üîê Weryfikacja", style=discord.ButtonStyle.gray)
    async def v(self, i: discord.Interaction, b: Button):
        await i.response.send_message("Kliknij panel weryfikacji", ephemeral=True)

DYNAMIC_CHANNELS = {}

# ================== SLASH COMMANDY ==================
@bot.tree.command(name="ping", description="Sprawd≈∫ czy bot ≈ºyje", guild=discord.Object(id=GUILD_ID))
async def ping(interaction: discord.Interaction):
    await interaction.response.send_message(f"üèì Pong! `{round(bot.latency*1000)} ms`", ephemeral=True)
    log_to_file(f"Slash /ping u≈ºyty przez {interaction.user} na {interaction.channel}")

@bot.tree.command(name="weryfikacja", guild=discord.Object(id=GUILD_ID))
@app_commands.checks.has_permissions(administrator=True)
async def weryfikacja(interaction: discord.Interaction):
    await interaction.channel.send("üîê Kliknij aby siƒô zweryfikowaƒá:", view=VerifyView())
    await interaction.response.send_message("‚úÖ Panel wys≈Çany", ephemeral=True)
    log_to_file(f"Slash /weryfikacja u≈ºyty przez {interaction.user} na {interaction.channel}")

@bot.tree.command(name="ticket", guild=discord.Object(id=GUILD_ID))
async def ticket(interaction: discord.Interaction):
    await interaction.response.send_message("üìÇ Wybierz typ ticketu:", view=TicketView(), ephemeral=True)
    log_to_file(f"Slash /ticket u≈ºyty przez {interaction.user} na {interaction.channel}")

@bot.tree.command(name="menu", guild=discord.Object(id=GUILD_ID))
async def menu(interaction: discord.Interaction):
    await interaction.response.send_message("üìå Menu serwera:", view=MenuView(), ephemeral=True)
    log_to_file(f"Slash /menu u≈ºyty przez {interaction.user} na {interaction.channel}")

@bot.tree.command(name="max2", guild=discord.Object(id=GUILD_ID))
async def max2(interaction: discord.Interaction, channel: discord.VoiceChannel):
    DYNAMIC_CHANNELS[channel.id] = 2
    await interaction.response.send_message("‚úÖ MAX2 ustawione", ephemeral=True)
    log_to_file(f"{interaction.user} ustawi≈Ç MAX2 na {channel}")

@bot.tree.command(name="max3", guild=discord.Object(id=GUILD_ID))
async def max3(interaction: discord.Interaction, channel: discord.VoiceChannel):
    DYNAMIC_CHANNELS[channel.id] = 3
    await interaction.response.send_message("‚úÖ MAX3 ustawione", ephemeral=True)
    log_to_file(f"{interaction.user} ustawi≈Ç MAX3 na {channel}")

@bot.tree.command(name="max4", guild=discord.Object(id=GUILD_ID))
async def max4(interaction: discord.Interaction, channel: discord.VoiceChannel):
    DYNAMIC_CHANNELS[channel.id] = 4
    await interaction.response.send_message("‚úÖ MAX4 ustawione", ephemeral=True)
    log_to_file(f"{interaction.user} ustawi≈Ç MAX4 na {channel}")

@bot.tree.command(name="max5", guild=discord.Object(id=GUILD_ID))
async def max5(interaction: discord.Interaction, channel: discord.VoiceChannel):
    DYNAMIC_CHANNELS[channel.id] = 5
    await interaction.response.send_message("‚úÖ MAX5 ustawione", ephemeral=True)
    log_to_file(f"{interaction.user} ustawi≈Ç MAX5 na {channel}")

YTDL_OPTIONS = {
    "format": "bestaudio/best",
    "noplaylist": True,
    "quiet": True,
    "default_search": "ytsearch",
    "source_address": "0.0.0.0"
}
FFMPEG_OPTIONS = {
    "before_options": "-reconnect 1 -reconnect_streamed 1 -reconnect_delay_max 5",
    "options": "-vn"
}

@bot.tree.command(name="play", guild=discord.Object(id=GUILD_ID))
async def play(interaction: discord.Interaction, query: str):
    if not interaction.user.voice:
        await interaction.response.send_message("‚ùå Wejd≈∫ na VC", ephemeral=True)
        return
    await interaction.response.defer(ephemeral=True)
    try:
        vc = discord.utils.get(bot.voice_clients, guild=interaction.guild)
        if not vc:
            vc = await interaction.user.voice.channel.connect()
        def extract():
            with yt_dlp.YoutubeDL(YTDL_OPTIONS) as ydl:
                return ydl.extract_info(query, download=False)
        info = await asyncio.to_thread(extract)
        if "entries" in info:
            info = info["entries"][0]
        if vc.is_playing():
            vc.stop()
        vc.play(discord.FFmpegPCMAudio(info["url"], **FFMPEG_OPTIONS))
        await interaction.followup.send(f"üéµ **{info['title']}**", ephemeral=True)
        log_to_file(f"{interaction.user} odtworzy≈Ç {info['title']} w {interaction.user.voice.channel}")
    except Exception as e:
        await interaction.followup.send("‚ùå B≈ÇƒÖd odtwarzania", ephemeral=True)
        log_to_file(f"B≈ÇƒÖd play: {e}")

@bot.tree.command(name="stop", guild=discord.Object(id=GUILD_ID))
async def stop(interaction: discord.Interaction):
    vc = discord.utils.get(bot.voice_clients, guild=interaction.guild)
    if vc and vc.is_playing():
        vc.stop()
        await interaction.response.send_message("‚èπÔ∏è Zatrzymano", ephemeral=True)
        log_to_file(f"{interaction.user} zatrzyma≈Ç odtwarzanie w {vc.channel}")
    else:
        await interaction.response.send_message("‚ùå Nic nie gra", ephemeral=True)

# ================== VOICE & STATUS LOGI ==================
@bot.event
async def on_voice_state_update(member, before, after):
    if before.channel != after.channel:
        if after.channel:
            log_to_file(f"{member} do≈ÇƒÖczy≈Ç do VC {after.channel}")
        if before.channel:
            log_to_file(f"{member} opu≈õci≈Ç VC {before.channel}")
    # MAX dynamiczny
    if after.channel and after.channel.id in DYNAMIC_CHANNELS:
        limit = DYNAMIC_CHANNELS[after.channel.id]
        vc = await member.guild.create_voice_channel(
            f"{member.display_name}", user_limit=limit
        )
        await member.move_to(vc)
    if before.channel and before.channel.id in DYNAMIC_CHANNELS:
        if len(before.channel.members) == 0:
            await before.channel.delete()

@bot.event
async def on_presence_update(before, after):
    if before.status != after.status:
        log_to_file(f"{after} zmieni≈Ç status z `{before.status}` na `{after.status}`")

# ================== ON_MESSAGE + GRY ==================
@bot.event
async def on_message(message):
    global last_word, last_number, last_user_game
    if message.author.bot:
        return

    # log
    log_to_file(f"Wiadomo≈õƒá od {message.author} na {message.channel}: `{message.content}`")

    # ===== OSTATNIA LITERA =====
    if message.channel.id == OSTATNIA_LITERA_ID:
        word = message.content.lower().strip()
        if not word.isalpha() or (last_word and word[0] != last_word[-1]) or last_user_game["litera"] == message.author.id:
            await message.delete()
            return
        last_word = word
        last_user_game["litera"] = message.author.id
        return

    # ===== OSOBA PONI≈ªEJ =====
    if message.channel.id == OSOBA_PONIZEJ_ID:
        if not message.content.lower().startswith(("tak", "nie")):
            await message.delete()
            return
        return

    # ===== LICZENIA =====
    if message.channel.id == LICZENIA_ID:
        try:
            number = int(message.content)
        except ValueError:
            await message.delete()
            return
        if number != last_number + 1 or last_user_game["liczenia"] == message.author.id:
            await message.delete()
            return
        last_number = number
        last_user_game["liczenia"] = message.author.id
        return

    await bot.process_commands(message)

# ================== RESET GIER ==================
@bot.command()
@commands.has_permissions(administrator=True)
async def reset(ctx, gra: str):
    global last_word, last_number, last_user_game
    if gra == "litera":
        last_word = None
        last_user_game["litera"] = None
        await ctx.send("üîÅ Zresetowano ostatniƒÖ literƒô")
    elif gra == "liczenia":
        last_number = 0
        last_user_game["liczenia"] = None
        await ctx.send("üîÅ Zresetowano liczenia")
    else:
        await ctx.send("‚ùå Dostƒôpne: litera / liczenia")

# ================== ON_INTERACTION LOG ==================
@bot.event
async def on_interaction(interaction: discord.Interaction):
    if interaction.type.name == "application_command":
        log_to_file(
            f"Slash `{interaction.command.name}` u≈ºyty przez {interaction.user} "
            f"na {interaction.channel}"
        )
    elif interaction.type.name == "message_component":
        log_to_file(
            f"Komponent `{interaction.data.get('custom_id','brak id')}` "
            f"klikniƒôty przez {interaction.user}"
        )
#=====
@bot.event
async def on_ready():
    await bot.change_presence(activity=discord.Game(name="Bot Online!"))
    await bot.tree.sync(guild=discord.Object(id=GUILD_ID))
    print(f"‚úÖ Zalogowano jako {bot.user}")

# ================== START ==================
def start_bot(token):
    bot.run(token)
